### Trying out function templates

Function template is the mechanism to avoid repeating writing function (overload function)

	template <typename T> T maximum(T a, T b); // Declare template function

	int main(int argc, char ** argv){
		int a{10};
		int b{23};
		double c{34.7};
		double d{23.4};
		std::string e{"hello"};
		std::string f{" world"};
		std::cout << "max(int): " << maximum(a,b) << std::endl; // int version created
		std::cout << "max(double): " << maximum(c,d) << std::endl; //double version created
		std::cout << "max(string): " << maximum(e,f) << std::endl; // string version created
		return 0;
	}
	template <typename T> T maximum(T a, T b){
		return (a > b) ? a:b; // a and b must be support > operator, otherwise hard ERROR
	} 

- Function templates are just blueprints, They are not real C++ code consumed by the compiler, The compiler generates real C++ code by looking at the arguments you call your function template with.

- The real C++ function generated by the compiler is called a template instance.

- A template instance will be reused when a similar function call (argument types) is issued. No duplicates are generated by the compiler

		# include <iostream>
		# include <string>
		template<typename T>
		T maximum(T a, T b);
		; // Declare maximum template function
		int main(int argc, char ** argv)
		{
		  int a = {10};
		  int b = {23};
		  double c = {34.700000000000003};
		  double d = {23.399999999999999};
		  std::basic_string<char> e = std::basic_string<char>{"hello", std::allocator<char>()};
		  std::basic_string<char> f = std::basic_string<char>{" world", std::allocator<char>()};
		  std::operator<<(std::cout, "max(int): ").operator<<(maximum(a, b)).operator<<(std::endl);
		  std::operator<<(std::cout, "max(double): ").operator<<(maximum(c, d)).operator<<(std::endl);
		  std::operator<<(std::operator<<(std::cout, "max(string): "), maximum(std::basic_string<char>(e), std::basic_string<char>(f))).operator<<(std::endl);
		  return 0;
		}

		template<typename T>
		T maximum(T a, T b)
		{
		  return (a > b) ? a : b;
		}

		/* First instantiated from: insights.cpp:16 */
		#ifdef INSIGHTS_USE_TEMPLATE
		template<>
		int maximum<int>(int a, int b)
		{
		  return (a > b) ? a : b;
		}
		#endif


		/* First instantiated from: insights.cpp:17 */
		#ifdef INSIGHTS_USE_TEMPLATE
		template<>
		double maximum<double>(double a, double b)
		{
		  return (a > b) ? a : b;
		}
		#endif

		/* First instantiated from: insights.cpp:18 */
		#ifdef INSIGHTS_USE_TEMPLATE
		template<>
		std::basic_string<char> maximum<std::basic_string<char> >(std::basic_string<char> a, std::basic_string<char> b)
		{
		  return std::basic_string<char>((std::operator>(a, b)) ? a : b);
		}
		#endif


You can tricky do this

	template <typename T> T maximum(T a, T b);
	template <typename T> T multiply(T a, T b);

	int main(){
		std::string x{"Hello"};
		std::string y{" World!"};
		auto result = maximum(x,y);

		auto number = multiply(a,b);
	}

	template <typename T> T maximum(T a, T b){
		return (a > b)? a:b;
	}

	template <typename T> T multiply(T a, T b){
		return a * b
	}

Summary:

- Function templates are just blueprints, they are not real function declaration and definition.

- Real function declarations and definitions, aka template instances are created when you call the function with arguments

- If the template parameters are of the same type (T.T), then the arguments you call the function with must also match, otherwise you get a compiler error.

- Template instances will not always do what you want, A good exmple is when you call our maximum function with pointers, DISASTER! (We are compare the function not the value)

		int x{5};
		int y{7};
		int* p_x{&x};
		int* p_y{&y};
		auto result = maximum(p_x,p_y);
		std::cout << "result: " << * result << std::endl;


- There are tools like `cppinsights.io` that can show you template instantiations. You can even use the debugger to infer that information from the activation record of template function. 

- The arguments passed to a function template must support the operations thate are done in the body of the function.